import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// Clase base para los nodos del árbol de expresiones
abstract class Nodo {
    abstract double evaluar();
}

// Nodo hoja (representa operandos)
class NodoOperando extends Nodo {
    double valor;

    public NodoOperando(double valor) {
        this.valor = valor;
    }

    @Override
    double evaluar() {
        return valor;
    }
}

// Nodo operador (realiza operaciones matemáticas)
class NodoOperador extends Nodo {
    char operador;
    Nodo izquierdo, derecho;

    public NodoOperador(char operador, Nodo izquierdo, Nodo derecho) {
        this.operador = operador;
        this.izquierdo = izquierdo;
        this.derecho = derecho;
    }

    @Override
    double evaluar() {
        double valorIzquierdo = izquierdo != null ? izquierdo.evaluar() : 0;
        double valorDerecho = derecho.evaluar();

        // Evaluación de operaciones matemáticas
        switch (operador) {
            case '+': return valorIzquierdo + valorDerecho;
            case '-': return valorIzquierdo - valorDerecho;
            case '*': return valorIzquierdo * valorDerecho;
            case '/': return valorDerecho != 0 ? valorIzquierdo / valorDerecho : Double.NaN; // Evita división por 0
            case '^': return Math.pow(valorIzquierdo, valorDerecho);
            case '√': return Math.sqrt(valorDerecho); // √(n) representa raíz cuadrada
            default: throw new IllegalArgumentException("Operador no soportado: " + operador);
        }
    }
}

// Parser para construir el árbol de expresiones
class AnalizadorExpresion {
    public static Nodo analizar(String expresion) {
        expresion = expresion.replaceAll("[{}\\[\\]]", ""); // Elimina {}, []
        return construirArbol(expresion);
    }

    private static Nodo construirArbol(String expresion) {
        Stack<Nodo> pilaOperandos = new Stack<>();
        Stack<Character> pilaOperadores = new Stack<>();

        // Expresión regular para detectar números y operadores (incluye √)
        Pattern patron = Pattern.compile("\\d+(\\.\\d+)?|[+\\-*/^√()]");
        Matcher coincidencia = patron.matcher(expresion);

        while (coincidencia.find()) {
            String token = coincidencia.group();

            if (token.matches("\\d+(\\.\\d+)?")) { // Si es número
                pilaOperandos.push(new NodoOperando(Double.parseDouble(token)));
            } else if (token.equals("(")) {
                pilaOperadores.push('(');
            } else if (token.equals(")")) {
                while (!pilaOperadores.isEmpty() && pilaOperadores.peek() != '(') {
                    procesarOperador(pilaOperandos, pilaOperadores.pop());
                }
                pilaOperadores.pop(); // Eliminar el '('
            } else if ("+-*/^√".contains(token)) { // Si es operador
                char operador = token.charAt(0);
                while (!pilaOperadores.isEmpty() && precedencia(pilaOperadores.peek()) >= precedencia(operador)) {
                    procesarOperador(pilaOperandos, pilaOperadores.pop());
                }
                pilaOperadores.push(operador);
            }
        }

        // Procesar los operadores restantes
        while (!pilaOperadores.isEmpty()) {
            procesarOperador(pilaOperandos, pilaOperadores.pop());
        }

        return pilaOperandos.pop();
    }

    private static void procesarOperador(Stack<Nodo> pilaOperandos, char operador) {
        Nodo derecho = pilaOperandos.pop();
        Nodo izquierdo = operador == '√' ? null : pilaOperandos.pop();
        pilaOperandos.push(new NodoOperador(operador, izquierdo, derecho));
    }

    private static int precedencia(char operador) {
        switch (operador) {
            case '+': case '-': return 1;
            case '*': case '/': return 2;
            case '^': case '√': return 3;
            default: return -1;
        }
    }
}

// Clase principal para probar el árbol de expresiones
public class ArbolExpresion {
    public static void main(String[] args) {
        String expresion1 = "(5 + 7) * (6 - 2)";
        String expresion2 = "8+1*3^2-6/4+21*4√16";
        String expresion3 = "((3 + 4) * 2 ) / 7";

        Nodo raiz1 = AnalizadorExpresion.analizar(expresion1);
        System.out.println("Resultado de '" + expresion1 + "': " + raiz1.evaluar());

        Nodo raiz2 = AnalizadorExpresion.analizar(expresion2);
        System.out.println("Resultado de '" + expresion2 + "': " + raiz2.evaluar());

        Nodo raiz3 = AnalizadorExpresion.analizar(expresion3);
        System.out.println("Resultado de '" + expresion3 + "': " + raiz3.evaluar());
    }
}
